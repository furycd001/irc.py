#!/usr/bin/env python3

import curses
import re
import ssl
import socket
import threading
import time
import sys
from collections import deque

# CONFIG

SERVERS = [
    {
        "name":     "Libera",
        "host":     "irc.libera.chat",
        "port":     6697,
        "nick":     "YourNickHere",
        "pass":     "YourPasswordHere",
        "channels": ["#yourchannel"],
    },
    
    # {
    #     "name":     "OFTC",
    #     "host":     "irc.oftc.net",
    #     "port":     6697,
    #     "nick":     "YourNick",
    #     "pass":     "",
    #     "channels": ["#debian"],
    # },
]

RECONNECT_DELAY = 20
MAX_BUFFER      = 500

# SEGMENT TYPES

S_NORMAL = 0
S_NICK   = 1
S_SELF   = 2
S_STATUS = 3
S_PM     = 4

# DATA MODEL

class Tab:
    def __init__(self, server_name: str, name: str, is_nickserv: bool = False):
        self.server_name = server_name
        self.name        = name
        self.is_nickserv = is_nickserv
        self.buffer: deque = deque(maxlen=MAX_BUFFER)
        self.unread  = False
        self._lock   = threading.Lock()

    @property
    def label(self) -> str:
        short = "NS" if self.is_nickserv else self.name
        return f"{self.server_name}/{short}"

    def append(self, segments: list) -> None:
        with self._lock:
            self.buffer.append(segments)
        self.unread = True

    def lines(self) -> list:
        with self._lock:
            return list(self.buffer)


_IRC_FMT = re.compile(r"\x03(?:\d{1,2}(?:,\d{1,2})?)?|[\x02\x1d\x1f\x16\x0f]")

def _strip(text: str) -> str:
    return _IRC_FMT.sub("", text)


class IRCServer:

    def __init__(self, cfg: dict, on_update, on_new_tab):
        self.cfg         = cfg
        self.name        = cfg["name"]
        self.nick        = cfg["nick"]
        self._on_update  = on_update
        self._on_new_tab = on_new_tab
        self._sock       = None
        self._slock      = threading.Lock()
        self._running    = False
        self.ns_tab      = Tab(self.name, "NickServ", is_nickserv=True)
        self.chan_tabs: dict[str, Tab] = {}
        for c in cfg["channels"]:
            self.chan_tabs[c] = Tab(self.name, c)

    def initial_tabs(self) -> list:
        return [self.ns_tab] + list(self.chan_tabs.values())

    def all_tabs(self) -> list:
        return [self.ns_tab] + list(self.chan_tabs.values())

    # Networking

    def start(self) -> None:
        self._running = True
        threading.Thread(target=self._loop, daemon=True, name=self.name).start()

    def stop(self) -> None:
        self._running = False
        self.send("QUIT :Goodbye")

    def send(self, msg: str) -> None:
        if self._sock:
            try:
                with self._slock:
                    self._sock.sendall((msg + "\r\n").encode("utf-8", errors="replace"))
            except Exception:
                pass

    # Internal helpers

    def _status(self, tab: Tab, text: str) -> None:
        tab.append([(f"-- {text} --", S_STATUS)])
        self._on_update(tab)

    def _loop(self) -> None:
        while self._running:
            self._status(self.ns_tab,
                         f"connecting to {self.cfg['host']}:{self.cfg['port']}…")
            try:
                raw = socket.create_connection(
                    (self.cfg["host"], self.cfg["port"]), timeout=30)
                ctx = ssl.create_default_context()
                self._sock = ctx.wrap_socket(raw, server_hostname=self.cfg["host"])
                self._sock.settimeout(None)
                self.send(f"PASS {self.cfg['pass']}")
                self.send(f"NICK {self.nick}")
                self.send(f"USER {self.nick} 0 * :{self.nick}")
                self._read()
            except Exception as exc:
                self._status(self.ns_tab, f"error: {exc}")
            finally:
                if self._sock:
                    try:
                        self._sock.close()
                    except Exception:
                        pass
                    self._sock = None
            if self._running:
                for tab in self.all_tabs():
                    self._status(tab,
                                 f"disconnected — reconnecting in {RECONNECT_DELAY}s…")
                time.sleep(RECONNECT_DELAY)

    def _read(self) -> None:
        buf = ""
        while self._running:
            try:
                chunk = self._sock.recv(4096)
                if not chunk:
                    break
                buf += chunk.decode("utf-8", errors="replace")
                while "\r\n" in buf:
                    line, buf = buf.split("\r\n", 1)
                    self._parse(line)
            except Exception:
                break

    def _parse(self, raw: str) -> None:
        if raw.startswith("PING "):
            self.send("PONG " + raw[5:])
            return

        parts    = raw.split(" ", 3)
        if len(parts) < 2:
            return
        prefix   = parts[0].lstrip(":")
        cmd      = parts[1]
        param    = parts[2].strip() if len(parts) > 2 else ""
        trail    = _strip(parts[3].lstrip(":")) if len(parts) > 3 else ""
        src_nick = prefix.split("!")[0]

        if cmd in ("376", "422"):
            for chan in list(self.chan_tabs.keys()):
                self.send(f"JOIN {chan}")
            return

        if cmd == "JOIN":
            chan = param.lstrip(":").strip()
            if src_nick == self.nick:
                if chan not in self.chan_tabs:
                    tab = Tab(self.name, chan)
                    self.chan_tabs[chan] = tab
                    self._on_new_tab(tab)
                self._status(self.chan_tabs[chan], f"joined {chan}")
            return

        if cmd == "PART":
            return

        if cmd == "PRIVMSG":
            target = param
            if target.startswith("#"):
                tab = self.chan_tabs.get(target)
                if tab:
                    tab.append([
                        (f"<{src_nick}>", S_NICK),
                        (f" {trail}",     S_NORMAL),
                    ])
                    self._on_update(tab)
            elif target == self.nick:
                self.ns_tab.append([
                    (f"[PM from {src_nick}]", S_PM),
                    (f" {trail}",             S_NORMAL),
                ])
                self._on_update(self.ns_tab)
            return

        if cmd == "NOTICE":
            self.ns_tab.append([
                (f"[{src_nick}]", S_STATUS),
                (f" {trail}",     S_NORMAL),
            ])
            self._on_update(self.ns_tab)
            return


# UI

class UI:

    def __init__(self, stdscr):
        self.scr       = stdscr
        self.tabs: list[Tab]               = []
        self.servers: dict[str, IRCServer] = {}
        self.active    = 0
        self.input     = ""
        self.hist: list[str] = []
        self.hist_pos  = -1
        self._lock     = threading.Lock()
        self._dirty    = threading.Event()
        self._cmd_server: str | None = None
        self._init_curses()
        self._init_colors()

    # Setup

    def _init_curses(self) -> None:
        curses.curs_set(1)
        curses.noecho()
        curses.cbreak()
        self.scr.keypad(True)
        self.scr.timeout(100)

    def _init_colors(self) -> None:
        curses.start_color()
        curses.use_default_colors()
        curses.init_pair(1, curses.COLOR_CYAN,   -1)
        curses.init_pair(2, curses.COLOR_WHITE,  -1)
        curses.init_pair(3, curses.COLOR_YELLOW, -1)
        curses.init_pair(4, curses.COLOR_WHITE,  -1)
        curses.init_pair(5, curses.COLOR_WHITE,  -1)

    def _seg_attr(self, seg_type: int) -> int:
        if seg_type == S_NICK:   return curses.color_pair(4) | curses.A_BOLD
        if seg_type == S_SELF:   return curses.color_pair(1) | curses.A_BOLD
        if seg_type == S_STATUS: return curses.color_pair(5) | curses.A_DIM
        if seg_type == S_PM:     return curses.color_pair(3) | curses.A_BOLD
        return 0

    # Server / tab management

    def add_server(self, cfg: dict) -> None:
        srv = IRCServer(cfg, self._on_update, self._on_new_tab)
        self.servers[cfg["name"]] = srv
        with self._lock:
            for tab in srv.initial_tabs():
                self.tabs.append(tab)
        srv.start()

    def _on_update(self, tab: Tab) -> None:
        if self.tabs and tab is not self.tabs[self.active]:
            tab.unread = True
        self._dirty.set()

    def _on_new_tab(self, tab: Tab) -> None:
        with self._lock:
            if tab not in self.tabs:
                self.tabs.append(tab)
        self._dirty.set()

    def _switch(self, idx: int) -> None:
        if 0 <= idx < len(self.tabs):
            self.active = idx
            self.tabs[idx].unread = False
            self.input    = ""
            self.hist_pos = -1
            self.draw()

    def _cycle(self, direction: int) -> None:
        if self.tabs:
            self._switch((self.active + direction) % len(self.tabs))

    # Drawing

    def draw(self) -> None:
        try:
            rows, cols = self.scr.getmaxyx()
            if rows < 4 or cols < 10:
                return
            self.scr.erase()
            self._draw_tabbar(cols)
            self._draw_sep(cols)
            self._draw_messages(rows, cols)
            self._draw_input(rows, cols)
            self.scr.refresh()
        except curses.error:
            pass

    def _draw_tabbar(self, cols: int) -> None:
        x = 0
        for i, tab in enumerate(self.tabs):
            num   = (i + 1) if i < 9 else 0
            label = f" {num}:{tab.label} "
            if x + len(label) > cols:
                break
            if i == self.active:
                attr = curses.color_pair(1) | curses.A_BOLD | curses.A_REVERSE
            elif tab.unread:
                attr = curses.color_pair(3) | curses.A_BOLD
            else:
                attr = curses.color_pair(2) | curses.A_DIM
            try:
                self.scr.addstr(0, x, label, attr)
            except curses.error:
                break
            x += len(label)

    def _draw_sep(self, cols: int) -> None:
        try:
            self.scr.addstr(1, 0, "─" * (cols - 1), curses.A_DIM)
        except curses.error:
            pass

    def _draw_messages(self, rows: int, cols: int) -> None:
        if not self.tabs:
            return
        msg_area  = rows - 3
        all_lines = self.tabs[self.active].lines()
        visible   = all_lines[-msg_area:] if len(all_lines) > msg_area else all_lines
        row       = 2 + (msg_area - len(visible))
        for segs in visible:
            try:
                self.scr.move(row, 0)
                self.scr.clrtoeol()
                x = 0
                for text, seg_type in segs:
                    attr = self._seg_attr(seg_type)
                    safe = text[: cols - x]
                    if safe:
                        self.scr.addstr(row, x, safe, attr)
                    x += len(safe)
                    if x >= cols:
                        break
            except curses.error:
                pass
            row += 1

    def _draw_input(self, rows: int, cols: int) -> None:
        row = rows - 1
        try:
            self.scr.move(row, 0)
            self.scr.clrtoeol()
            if not self.tabs:
                return
            tab    = self.tabs[self.active]
            prompt = "[NickServ] > " if tab.is_nickserv else f"[{tab.name}] > "
            full   = prompt + self.input
            self.scr.addstr(row, 0, full[: cols - 1], curses.color_pair(1))
            self.scr.move(row, min(len(full), cols - 1))
        except curses.error:
            pass

    # Command processing

    def _active_server(self) -> "IRCServer | None":
        if not self.tabs:
            return None
        return self.servers.get(self.tabs[self.active].server_name)

    def _cmd_ctx_server(self) -> "IRCServer | None":
        if self._cmd_server:
            return self.servers.get(self._cmd_server)
        return self._active_server()

    def _process(self, text: str) -> None:
        if not text:
            return
        if not self.hist or self.hist[0] != text:
            self.hist.insert(0, text)
            if len(self.hist) > 200:
                self.hist = self.hist[:200]
        self.hist_pos = -1

        if not text.startswith("/"):
            tab = self.tabs[self.active] if self.tabs else None
            srv = self._active_server()
            if not tab or not srv:
                return
            if tab.is_nickserv:
                srv.send(f"PRIVMSG NickServ :{text}")
                tab.append([
                    ("[you → NickServ]", S_STATUS),
                    (f" {text}",         S_NORMAL),
                ])
            else:
                srv.send(f"PRIVMSG {tab.name} :{text}")
                tab.append([
                    (f"<{srv.nick}>", S_SELF),
                    (f" {text}",      S_NORMAL),
                ])
            tab.unread = False
            self.draw()
            return

        parts = text[1:].split(" ", 2)
        cmd   = parts[0].lower()
        arg1  = parts[1].strip() if len(parts) > 1 else ""
        rest  = parts[2]         if len(parts) > 2 else ""

        if cmd == "quit":
            for srv in self.servers.values():
                srv.stop()
            time.sleep(0.3)
            raise SystemExit

        elif cmd == "server":
            if arg1 in self.servers:
                self._cmd_server = arg1
                for i, t in enumerate(self.tabs):
                    if t.server_name == arg1 and t.is_nickserv:
                        self._switch(i)
                        break
            else:
                names = ", ".join(self.servers.keys())
                if self.tabs:
                    self.tabs[self.active].append(
                        [(f"-- unknown server '{arg1}'. known: {names} --", S_STATUS)])
            self.draw()

        elif cmd == "join" and arg1:
            chan = arg1 if arg1.startswith("#") else "#" + arg1
            srv  = self._cmd_ctx_server()
            if srv:
                self._cmd_server = None
                if chan not in srv.chan_tabs:
                    tab = Tab(srv.name, chan)
                    srv.chan_tabs[chan] = tab
                    with self._lock:
                        self.tabs.append(tab)
                srv.send(f"JOIN {chan}")
                for i, t in enumerate(self.tabs):
                    if t.server_name == srv.name and t.name == chan:
                        self._switch(i)
                        break

        elif cmd == "part":
            tab = self.tabs[self.active] if self.tabs else None
            srv = self._active_server()
            if srv and tab and not tab.is_nickserv:
                chan = arg1 if arg1 else tab.name
                srv.send(f"PART {chan}")
                with self._lock:
                    if tab in self.tabs:
                        idx = self.tabs.index(tab)
                        self.tabs.pop(idx)
                        srv.chan_tabs.pop(chan, None)
                        self.active = max(0, min(idx, len(self.tabs) - 1))
            self.draw()

        elif cmd == "ns" and arg1:
            ns_cmd = (arg1 + " " + rest).strip()
            srv    = self._active_server()
            if srv:
                srv.send(f"PRIVMSG NickServ :{ns_cmd}")
                srv.ns_tab.append([
                    ("[you → NickServ]", S_STATUS),
                    (f" {ns_cmd}",       S_NORMAL),
                ])
                for i, t in enumerate(self.tabs):
                    if t is srv.ns_tab:
                        self._switch(i)
                        break

        elif cmd == "msg" and arg1:
            srv = self._active_server()
            tab = self.tabs[self.active] if self.tabs else None
            if srv and tab:
                srv.send(f"PRIVMSG {arg1} :{rest}")
                tab.append([
                    (f"[PM to {arg1}]", S_PM),
                    (f" {rest}",        S_NORMAL),
                ])
                self.draw()

        else:
            srv = self._active_server()
            if srv:
                srv.send(text[1:])

    # Main loop

    def run(self) -> None:
        self.draw()
        while True:
            if self._dirty.is_set():
                self._dirty.clear()
                self.draw()

            ch = self.scr.getch()
            if ch == -1:
                continue

            if ch == curses.KEY_RESIZE:
                self.draw()
                continue

            if ch == 12:
                self.draw()
                continue

            if ch == 27:
                self.scr.timeout(50)
                nxt = self.scr.getch()
                self.scr.timeout(100)

                if nxt == -1:
                    continue

                if nxt == ord("["):
                    seq = ""
                    self.scr.timeout(50)
                    while True:
                        c2 = self.scr.getch()
                        if c2 == -1 or (c2 != ord(";") and not (48 <= c2 <= 57)):
                            seq += chr(c2) if c2 != -1 else ""
                            break
                        seq += chr(c2)
                    self.scr.timeout(100)

                    if seq == "A":
                        if self.hist and self.hist_pos < len(self.hist) - 1:
                            self.hist_pos += 1
                            self.input = self.hist[self.hist_pos]
                            self._draw_input(*self.scr.getmaxyx())
                            self.scr.refresh()
                    elif seq == "B":
                        if self.hist_pos > 0:
                            self.hist_pos -= 1
                            self.input = self.hist[self.hist_pos]
                        else:
                            self.hist_pos = -1
                            self.input = ""
                        self._draw_input(*self.scr.getmaxyx())
                        self.scr.refresh()
                    elif seq in ("5C", "1;5C"):
                        self._cycle(+1)
                    elif seq in ("5D", "1;5D"):
                        self._cycle(-1)

                else:
                    if ord("1") <= nxt <= ord("9"):
                        self._switch(nxt - ord("1"))
                    elif nxt == ord("0"):
                        self._switch(9)
                continue

            if ch == 14:
                self._cycle(+1)
                continue
            if ch == 16:
                self._cycle(-1)
                continue

            if ch == curses.KEY_UP:
                if self.hist and self.hist_pos < len(self.hist) - 1:
                    self.hist_pos += 1
                    self.input = self.hist[self.hist_pos]
                    self._draw_input(*self.scr.getmaxyx())
                    self.scr.refresh()
                continue
            if ch == curses.KEY_DOWN:
                if self.hist_pos > 0:
                    self.hist_pos -= 1
                    self.input = self.hist[self.hist_pos]
                else:
                    self.hist_pos = -1
                    self.input = ""
                self._draw_input(*self.scr.getmaxyx())
                self.scr.refresh()
                continue

            if ch in (curses.KEY_BACKSPACE, 127, 8):
                self.input = self.input[:-1]
                self._draw_input(*self.scr.getmaxyx())
                self.scr.refresh()
                continue

            if ch in (10, 13):
                text = self.input.strip()
                self.input    = ""
                self.hist_pos = -1
                self._process(text)
                self.draw()
                continue

            if 32 <= ch <= 126:
                self.input += chr(ch)
                self._draw_input(*self.scr.getmaxyx())
                self.scr.refresh()


# ENTRY POINT

def main(stdscr):
    ui = UI(stdscr)
    for cfg in SERVERS:
        ui.add_server(cfg)
    ui.run()


if __name__ == "__main__":
    try:
        curses.wrapper(main)
    except (SystemExit, KeyboardInterrupt):
        pass
